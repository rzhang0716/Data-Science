str(fin)
fin$Profit <- as.numeric(as.character(fin$Profit))
summary(fin)
fin <- read.csv("future-500.csv")
summary(fin)
fin$Revenue <- gsub("\\S","",fin$Revenue)
fin$Revenue <- gsub(",","",fin$Revenue)
fin$Revenue <- as.numeric(fin$Revenue)
str(fin)
fin <- read.csv("future-500.csv")
fin$Revenue <- gsub("\\$","",fin$Revenue)
fin$Expenses <- gsub("Dollars","",fin$Expenses)
fin$Expenses <- as.numeric(fin$Expenses)
head(fin)
fin$Expenses <- gsub(",","",fin$Expenses)
str(fin)
fin$Revenue <- gsub("\\$","",fin$Revenue)
fin$Revenue <- gsub(",","",fin$Revenue)
fin$Revenue <- as.numeric(fin$Revenue)
str(fin)
fin$Growth <- gsub("%","",fin$Growth)
fin$Growth <- as.numeric(fin$Growth)
str(fin)
fin$Profit <- as.numeric(as.character(fin$Profit))
summary(fin)
#Locating Missing Value;
head(fin,24)
complete.cases(fin)
str(fin)
fin <- read.csv("future-500.csv")
complete.cases(fin)
fin[!complete.cases(fin),]
#Replace the missing as NA
fin <- read.csv("Future-500.csv", na.strings = c(""))
fin
fin[!complete.cases(fin),]
#
fin[fin$Revenue == 9746272,]
fin <- read.csv("future-500.csv")
str(fin)
fin$Expenses <- gsub("Dollars","",fin$Expenses)
fin$Expenses <- as.numeric(fin$Expenses)
str(fin)
fin <- read.csv("future-500.csv")
str(fin)
fin$Expenses <- gsub("Dollars","",fin$Expenses)
fin$Expenses <- gsub(",","",fin$Expenses)
fin$Expenses <- as.numeric(fin$Expenses)
str(fin)
fin$Revenue <- gsub("\\$","",fin$Revenue)
fin$Revenue <- gsub(",","",fin$Revenue)
fin$Revenue <- as.numeric(fin$Revenue)
str(fin)
fin$Growth <- gsub("%","",fin$Growth)
fin$Growth <- as.numeric(fin$Growth)
str(fin)
fin[!complete.cases(fin),]
hemangioma
hemangioma
hemangioma
data(hemangioma)
data("hemangioma")
read.table("data/hemangioma.txt", header = T)
setwd("~/Documents/course/Statistics/ST 537 (2019 Fall)/Homework/HW4")
data1 <- read.txt("hemangioma.txt")
data1 <- read.tabke("hemangioma.txt")
data1 <- read.table("hemangioma.txt")
data1 <- read.table("hemangioma.txt")
library()
data1
apply(data1,2,shapiro.test)
typeof(data1)
spply(data1[,1:8],shapiro.test)
sapply(data1[,1:8],shapiro.test)
data1 <- as.matrix(data1)
sapply(data1[,1:8],2,shapiro.test)
apply(data1,2,shapiro.test)
data1 <- as.matrix(data1)
apply(data1[,1:8],2,shapiro.test)
typeof(data1)
data1 <- as.numeric(as.matrix(data1))
data1
data1 <- read.table("hemangioma.txt")
data1 <- as.numeric(data1)
typeof(data1)
lapply(data1[,1:8],shapiro.test)
data1 <- matrix(unlist(data1), ncol=8, byrow=TRUE)
typeof(data1)
data1
data1 <- read.table("hemangioma.txt")
data1
unlist(data1)
typeof(data1)
?read.table
data1 <- read.table("hemangioma.txt",seq="")
data1 <- read.table("hemangioma.txt",sep ="")
typeof(data1)
data1 <- read.table("hemangioma.txt",sep ="\t")
typeof(data1)
data1 <- read.table("hemangioma.txt",sep ="\t")
data1
data1 <- as.data.frame(data1)
typeof(data1)
data1 <- read.csv("hemangioma.csv")
typeof(data1)
data1 <- read.csv("hemangioma.csv",sep = ",")
data1
unlist(data1)
data1 <- read.table("hemangioma.txt")
data1
data1 <- read.table("hemangioma.txt",header = FALSE)
data1
data1 <- read.table("hemangioma.txt",header = FALSE)
data1
data1 <- read.table("hemangioma.txt",header = TRUE)
data1
typeof(data1)
unlist(data1)
data1 <- matrix(unlist(data1), ncol=8, byrow=FALSE)
data1
colnames(data1) <- c("Age","RB","p16","DLK","Nanog","C.Myc","EZH2","IGF.2")
data1
apply(data1,2,shapiro.test)
library(MVN)
mvn(data1[,1:8], mvnTest = "royston",multivariatePlot = "qq")
bvbox(data1[ ,c("p16","EZH2")], pch=19, col="#990000",xlab="p16",ylab="EZH2",main="Bivariate boxplot")
library(MVN)
bvbox(data1[ ,c("p16","EZH2")], pch=19, col="#990000",xlab="p16",ylab="EZH2",main="Bivariate boxplot")
library(MVA)
install.packages("MVA")
install.packages("HSAUR2")
library(MVA)
library(HSAUR2)
library(tools)
library(MVA)
bvbox(data1[ ,c("p16","EZH2")], pch=19, col="#990000",xlab="p16",ylab="EZH2",main="Bivariate boxplot")
install.packages("sem")
?factanal
library(sem)
library(sem)
lt <- readMoments("../data/EverittEx5.5.txt", diag = T)
lt <- readMoments("EverittEx5.5.txt", diag = T)
R <- (lt + t(lt)) - diag(1, 6)
colnames(R) <- c("French", "English", "History", "Arithmetic", "Algebra", "Geometry")
rownames(R) <- c("French", "English", "History", "Arithmetic", "Algebra", "Geometry")
R
out2.1 <- factanal(R,factors = 2)
out2.1 <- factanal(R,factors = 2)
install.packages("psych")
install.packages("psych")
library(psych)
n_2a < - nrow(R)
nrow(R)
n_2a
n_2a < - nrow(R)
n_2 < - nrow(R)
n2 < - nrow(R)
n_2a <- nrow(R)
fa.mle_2a <- fa(r=R,n.obs=n_2a,rotate = "none",fm="ml")
fa.mle_2a
fa.mle_2a <- fa(r=R,n.obs=n_2a,nfactors= 2, rotate = "none",fm="ml")
fa.mle_2a
n_2b <- nrow(R)
fa.mle_2b <- fa(r=R,n.obs=n_2b,nfactors= 2, rotate = "varimax",fm="ml")
fa.mle_2b
fa.mle_2b
lt1 <- readMoments("EverittEx7.1.txt", diag = T)
R1 <- (lt1 + t(lt1)) - diag(1, 9)
R2 <- R[-9, -9]
R2
lt1 <- readMoments("EverittEx7.1.txt", diag = T)
?readMoment
lt1 <- readtable("EverittEx7.1.txt", diag = T)
lt1 <- read.table("EverittEx7.1.txt", diag = T)
lt1 <- readMoments("../data/EverittEx7.1.txt", diag = T)
lt1 <- readMoments("EverittEx7.1.txt", diag = T)
library(sem)
lt1 <- readMoments("EverittEx7.1.txt", diag = T)
R1 <- (lt1 + t(lt1)) - diag(1, 9)
R2 <- R[-9, -9]
R2
lt1 <- readMoments("EverittEx7.1.txt", diag = T)
lt1
R1 <- (lt1 + t(lt1)) - diag(1, 9)
R2 <- R1[-9, -9]
R2
ability_model <- specify.model(file="Problem3.txt")
ability_model <- specifyModel(file="Problem3.txt")
ability_model <- specifyModel(file="hw3.txt")
setwd("~/Documents/course/Statistics/ST 537 (2019 Fall)/Homework/HW4")
ability_model <- specifyModel(file="hw4.txt")
ability_model
ability_model <- specifyModel(file="hw4.txt")
ability_sem <- sem::sem(model=ability_model,S=R2,N=123)
ability_sem <- sem::sem(model=ability_model,S=DR,N=123)
ability_model <- specifyModel(file="hw4.txt")
ability_sem <- sem::sem(model=ability_model,S=R2,N=123)
summary(ability_sem)
ability_model <- specifyModel(file="hw4.txt")
ability_sem <- sem::sem(model=ability_model,S=R2,N=123)
summary(ability_sem)
install.packages("pathdiagram")
library(pathdiagram)
library(shape)
library(pathdiagram)
pathDiagram(ability_sem, ignore.double = FALSE, edge.labels = "both",file="ability_seb_fitted",output.type = "dot", node.colors = c("steelblue", "transparent"))
install.packages("DiagrammeR")
library(DiagrammeR)
library(DiagrammeR)
install.packages("munsell")
library(DiagrammeR)
install.packages("glue")
install.packages("glue")
library(DiagrammeR)
library(DiagrammeR)
grViz("ability_seb_fitted.dot")
#using is.na() for missing data;
head(fin,24)
mvn(data1[,1:8], mvnTest = "royston",multivariatePlot = "qq")
library(MVN)
mvn(data1[,1:8], mvnTest = "royston",multivariatePlot = "qq")
library(GGally)
library(ggplot2)
ggpairs(data1[,1:8])
data1
data1 <- matrix(unlist(data1), ncol=8, byrow=FALSE)
data1
par(mfrom=c(2,4))
par(mfrow=c(2,4))
for (ii in 1:8){
qqnorm(data1[,ii],
main=paste0("QQ plot of x", ii), pch=19, cex=1.5)
}
for (ii in 1:8){
qqnorm(data1[,ii],
main=paste0("QQ plot of x", ii), pch=19, cex=1.5)
}
for (ii in 1:8){
qqnorm(data1[,ii],
main=paste0("QQ plot of x", ii), pch=19, cex=1.5)
}
for (ii in 1:8){
qqnorm(data1[,ii],
main=paste0("QQ plot of x", ii), pch=19, cex=1.5)
}
library(sem)
lt <- readMoments("EverittEx5.5.txt", diag = T)
R <- (lt + t(lt)) - diag(1, 6)
colnames(R) <- c("French", "English", "History", "Arithmetic", "Algebra", "Geometry")
rownames(R) <- c("French", "English", "History", "Arithmetic", "Algebra", "Geometry")
R
library(psych)
n_2a <- nrow(R)
fa.mle_2a <- fa(r=R,n.obs=n_2a,nfactors= 2, rotate = "none",fm="ml")
library(psych)
n_2a <- nrow(R)
fa.mle_2a <- fa(r=R,n.obs=n_2a,nfactors= 2, rotate = "none",fm="ml")
fa.mle_2a
if (is.character(smplPois)){
lambda=1
smplPois=replicate(N,rpois(n,lambda))
} else {
# redefine n
n=length(smplPois)
}
# MLE estimators of lambda of the each sample
lambda.hat=colMeans(smplPois)
# Variance of the each sample
lambda.var=apply(smplPois,2,var)
##(b)Create and save a 95% CI for the mean of the population using the approximate confidence interval 1.
# construct the confidence intervals for mu in CIs for each of the samples
CI.1=cbind(lambda.hat-1.96*sqrt(lambda.var/n),
lambda.hat+1.96*sqrt(lambda.var/n))
##(c)Create and save a 95% CI for the mean of the population using the approximate confidence interval 2.
CI.2=cbind(lambda.hat-1.96*sqrt(lambda.hat/n),
lambda.hat+1.96*sqrt(lambda.hat/n))
##(d)Create and save 95% CIs for the mean of the population using the parametric bootstrap method. (B = 1000.)
# create dummy matrix
CI.3=matrix(NA,nrow=N,ncol=2)
B=1000
for (i in 1:N){
# Samples generated from poisson distribution with estimated lambda
Boot.par=replicate(n=B,expr=rpois(n,lambda.hat[i]))
# calculate mean(estimated lambda) and save in the vector
Boot.par.mean=colMeans(Boot.par)
# construct the confidence intervals for mu in CIs for each of the samples
CI.3[i,]=quantile(Boot.par.mean,c(0.025,0.975))
}
##(e)Create and save 95% CIs for the mean of the population using the nonparametric bootstrap method. (B = 1000.)
# create dummy matrix
CI.4=matrix(NA,nrow=N,ncol=2)
for (i in 1:N){
# sample n=10 from smplPois with replacement
Boot.non=replicate(n=B,sample(smplPois[,i],n,replace=TRUE))
# calculate mean(estimated lambda) and save in the vector
Boot.non.mean=colMeans(Boot.non)
#Approximate 95% CI (raw percentile)
CI.4[i,]=quantile(Boot.non.mean,c(0.025,0.975))
}
# Summarize the confidence intervals with different methods
if (N==1){
table=data.frame(c(CI.1[1],CI.2[1],CI.3[1],CI.4[1]),
c(CI.1[2],CI.2[2],CI.3[2],CI.4[2]),
row.names=c("Approximate 1","Approximate 2","Parametric Bootstrap","Nonparametric Bootstrap"))
colnames(table)=c("lcl","ucl")
} else {
##################################################################################################
# 3. In a table similar to that below, report the proportion of times each method contains the
# true value of the mean (1) and the average length of the CIs created by the procedure.
##################################################################################################
# Returns a vector of 1's and 0's. 1 means containing the true mean as 1, otherwise not.
propContain.1=mean((CI.1[,1]<lambda)*(CI.1[,2]>lambda))
propContain.2=mean((CI.2[,1]<lambda)*(CI.2[,2]>lambda))
propContain.3=mean((CI.3[,1]<lambda)*(CI.3[,2]>lambda))
propContain.4=mean((CI.4[,1]<lambda)*(CI.4[,2]>lambda))
# the average width of the intervals
avgLength.1=mean(CI.1[,2]-CI.1[,1])
avgLength.2=mean(CI.2[,2]-CI.2[,1])
avgLength.3=mean(CI.3[,2]-CI.3[,1])
avgLength.4=mean(CI.4[,2]-CI.4[,1])
# Create thetable to summarize the results
table=data.frame(c(propContain.1,propContain.2,propContain.3,propContain.4),
c(avgLength.1,avgLength.2,avgLength.3,avgLength.4),
row.names=c("Approximate 1","Approximate 2","Parametric Bootstrap","Nonparametric Bootstrap"))
colnames(table)=c("Prop Containing","Avg Length")
}
return(table)
}
myFunction=function(n, N, smplPois){
###################################################
# 1. General Procedure
###################################################
##(a)Generate a random sample of size n = 10 from a Poisson distribution with lambda=1.
if (is.character(smplPois)){
lambda=1
smplPois=replicate(N,rpois(n,lambda))
} else {
# redefine n
n=length(smplPois)
}
# MLE estimators of lambda of the each sample
lambda.hat=colMeans(smplPois)
# Variance of the each sample
lambda.var=apply(smplPois,2,var)
##(b)Create and save a 95% CI for the mean of the population using the approximate confidence interval 1.
# construct the confidence intervals for mu in CIs for each of the samples
CI.1=cbind(lambda.hat-1.96*sqrt(lambda.var/n),
lambda.hat+1.96*sqrt(lambda.var/n))
##(c)Create and save a 95% CI for the mean of the population using the approximate confidence interval 2.
CI.2=cbind(lambda.hat-1.96*sqrt(lambda.hat/n),
lambda.hat+1.96*sqrt(lambda.hat/n))
##(d)Create and save 95% CIs for the mean of the population using the parametric bootstrap method. (B = 1000.)
# create dummy matrix
CI.3=matrix(NA,nrow=N,ncol=2)
B=1000
for (i in 1:N){
# Samples generated from poisson distribution with estimated lambda
Boot.par=replicate(n=B,expr=rpois(n,lambda.hat[i]))
# calculate mean(estimated lambda) and save in the vector
Boot.par.mean=colMeans(Boot.par)
# construct the confidence intervals for mu in CIs for each of the samples
CI.3[i,]=quantile(Boot.par.mean,c(0.025,0.975))
}
##(e)Create and save 95% CIs for the mean of the population using the nonparametric bootstrap method. (B = 1000.)
# create dummy matrix
CI.4=matrix(NA,nrow=N,ncol=2)
for (i in 1:N){
# sample n=10 from smplPois with replacement
Boot.non=replicate(n=B,sample(smplPois[,i],n,replace=TRUE))
# calculate mean(estimated lambda) and save in the vector
Boot.non.mean=colMeans(Boot.non)
#Approximate 95% CI (raw percentile)
CI.4[i,]=quantile(Boot.non.mean,c(0.025,0.975))
}
# Summarize the confidence intervals with different methods
if (N==1){
table=data.frame(c(CI.1[1],CI.2[1],CI.3[1],CI.4[1]),
c(CI.1[2],CI.2[2],CI.3[2],CI.4[2]),
row.names=c("Approximate 1","Approximate 2","Parametric Bootstrap","Nonparametric Bootstrap"))
colnames(table)=c("lcl","ucl")
} else {
##################################################################################################
# 3. In a table similar to that below, report the proportion of times each method contains the
# true value of the mean (1) and the average length of the CIs created by the procedure.
##################################################################################################
# Returns a vector of 1's and 0's. 1 means containing the true mean as 1, otherwise not.
propContain.1=mean((CI.1[,1]<lambda)*(CI.1[,2]>lambda))
propContain.2=mean((CI.2[,1]<lambda)*(CI.2[,2]>lambda))
propContain.3=mean((CI.3[,1]<lambda)*(CI.3[,2]>lambda))
propContain.4=mean((CI.4[,1]<lambda)*(CI.4[,2]>lambda))
# the average width of the intervals
avgLength.1=mean(CI.1[,2]-CI.1[,1])
avgLength.2=mean(CI.2[,2]-CI.2[,1])
avgLength.3=mean(CI.3[,2]-CI.3[,1])
avgLength.4=mean(CI.4[,2]-CI.4[,1])
# Create thetable to summarize the results
table=data.frame(c(propContain.1,propContain.2,propContain.3,propContain.4),
c(avgLength.1,avgLength.2,avgLength.3,avgLength.4),
row.names=c("Approximate 1","Approximate 2","Parametric Bootstrap","Nonparametric Bootstrap"))
colnames(table)=c("Prop Containing","Avg Length")
}
return(table)
}
myFunction(n=10, N=1, 'NA')
myFunction(n=10, N=5000, 'NA')
myFunction(n=30, N=1, 'NA')
myFunction(n=30, N=5000, 'NA')
myFunction(n=10, N=1, 'NA')
myFunction(n=10, N=5000, 'NA')
set.seed(666)
# make sure the results are producible
set.seed(666)
#the self-defined function
# **********************************the beginning of myFnction*********************************
# n is the sample size, N is the number of repeating process
# smplPois means self defined data; smplPois="a" means data are simulated or smplPois is the external sample
myFunction=function(n, N, smplPois){
###################################################
# 1. General Procedure
###################################################
##(a)Generate a random sample of size n = 10 from a Poisson distribution with lambda=1.
if (is.character(smplPois)){
lambda=1
smplPois=replicate(N,rpois(n,lambda))
} else {
# redefine n
n=length(smplPois)
}
# MLE estimators of lambda of the each sample
lambda.hat=colMeans(smplPois)
# Variance of the each sample
lambda.var=apply(smplPois,2,var)
##(b)Create and save a 95% CI for the mean of the population using the approximate confidence interval 1.
# construct the confidence intervals for mu in CIs for each of the samples
CI.1=cbind(lambda.hat-1.96*sqrt(lambda.var/n),
lambda.hat+1.96*sqrt(lambda.var/n))
##(c)Create and save a 95% CI for the mean of the population using the approximate confidence interval 2.
CI.2=cbind(lambda.hat-1.96*sqrt(lambda.hat/n),
lambda.hat+1.96*sqrt(lambda.hat/n))
##(d)Create and save 95% CIs for the mean of the population using the parametric bootstrap method. (B = 1000.)
# create dummy matrix
CI.3=matrix(NA,nrow=N,ncol=2)
B=1000
for (i in 1:N){
# Samples generated from poisson distribution with estimated lambda
Boot.par=replicate(n=B,expr=rpois(n,lambda.hat[i]))
# calculate mean(estimated lambda) and save in the vector
Boot.par.mean=colMeans(Boot.par)
# construct the confidence intervals for mu in CIs for each of the samples
CI.3[i,]=quantile(Boot.par.mean,c(0.025,0.975))
}
##(e)Create and save 95% CIs for the mean of the population using the nonparametric bootstrap method. (B = 1000.)
# create dummy matrix
CI.4=matrix(NA,nrow=N,ncol=2)
for (i in 1:N){
# sample n=10 from smplPois with replacement
Boot.non=replicate(n=B,sample(smplPois[,i],n,replace=TRUE))
# calculate mean(estimated lambda) and save in the vector
Boot.non.mean=colMeans(Boot.non)
#Approximate 95% CI (raw percentile)
CI.4[i,]=quantile(Boot.non.mean,c(0.025,0.975))
}
# Summarize the confidence intervals with different methods
if (N==1){
table=data.frame(c(CI.1[1],CI.2[1],CI.3[1],CI.4[1]),
c(CI.1[2],CI.2[2],CI.3[2],CI.4[2]),
row.names=c("Approximate 1","Approximate 2","Parametric Bootstrap","Nonparametric Bootstrap"))
colnames(table)=c("lcl","ucl")
} else {
##################################################################################################
# 3. In a table similar to that below, report the proportion of times each method contains the
# true value of the mean (1) and the average length of the CIs created by the procedure.
##################################################################################################
# Returns a vector of 1's and 0's. 1 means containing the true mean as 1, otherwise not.
propContain.1=mean((CI.1[,1]<lambda)*(CI.1[,2]>lambda))
propContain.2=mean((CI.2[,1]<lambda)*(CI.2[,2]>lambda))
propContain.3=mean((CI.3[,1]<lambda)*(CI.3[,2]>lambda))
propContain.4=mean((CI.4[,1]<lambda)*(CI.4[,2]>lambda))
# the average width of the intervals
avgLength.1=mean(CI.1[,2]-CI.1[,1])
avgLength.2=mean(CI.2[,2]-CI.2[,1])
avgLength.3=mean(CI.3[,2]-CI.3[,1])
avgLength.4=mean(CI.4[,2]-CI.4[,1])
# Create thetable to summarize the results
table=data.frame(c(propContain.1,propContain.2,propContain.3,propContain.4),
c(avgLength.1,avgLength.2,avgLength.3,avgLength.4),
row.names=c("Approximate 1","Approximate 2","Parametric Bootstrap","Nonparametric Bootstrap"))
colnames(table)=c("Prop Containing","Avg Length")
}
return(table)
}
# **********************************the end of myFnction*********************************
#########################################################################################################
# 4. Repeat all of the above for n = 30 and n = 227, the latter is the size of the horse-kick death data.
#########################################################################################################
# when sample size n=10
myFunction(n=10, N=1, 'NA')
myFunction(n=10, N=5000, 'NA')
# when sample size n=30
myFunction(n=30, N=1, 'NA')
myFunction(n=30, N=5000, 'NA')
# when sample size n=227
myFunction(n=227, N=1, 'NA')
myFunction(n=227, N=5000, 'NA')
####################################################################################
# 6. Apply the 4 different methods to the horse-kick death data and report the 95%
# confidence intervals obtained by each method.
#####################################################################################
# store the horse-kick death data
# refer to textbook page 45
smplPois=matrix(c(rep(0, 109), rep(1,65), rep(2,22), rep(3,3), rep(4,1)),ncol=1)
myFunction(1,1,smplPois)
